#!/bin/bash

section='languages'
exclude_langs=()
include_langs=()

use_real_total=0

valid_ranges=(
    today
    yesterday
    week
    month
    year
    last_7_days
    7_days
    last_30_days
    30_days
    last_6_months
    6_months
    last_12_months
    12_months
    last_year
    any
    all_time
)

range=any

while getopts hTpr:x:i:a:u:t: OPT; do
    case $OPT in
    t) top=$OPTARG ;;
    p) section='projects' ;;
    r) range=$OPTARG ;;
    T) use_real_total=1 ;;
    x)
        include_langs=()
        : "${exclude_langs[$((${#exclude_langs[@]} + 1))]:=$OPTARG}"
        ;;
    i)
        exclude_langs=()
        : "${include_langs[$((${#include_langs[@]} + 1))]:=$OPTARG}"
        ;;
    a) api="$OPTARG" ;;
    u) user="$OPTARG" ;;
    h)
        IFS=$'\n'
        cat <<HELP 
lang-stats [Tprxi] [percentage...]
    Use wakapi to print language/project usage stats

    OPTIONS:
    u <user>   : the user to print stats for
    t <number> : display the top <number> languages/projects
    p          : print project times instead of language times
    r <range>  : time range, one of:
    $(printf '\t\t  %s\n' "${valid_ranges[@]}")
    x <names>  : exclude a ',' separated list of languages/projects
                 can be used multiple times.
                 Mutually exclusive with -i
    i <names>  : Similar to -x but ONLY show the languages listed with -i
                 Mutually exclusive with -x
    T          : When using -x or -i,
                 use the complete total seconds for the percentage instead
                 of only the total seconds of included langs/projects
    a <domain> : use <domain> as the api url base

    ARGUMENTS:
    percentage... :
                each arg is treated as a percentage to print to label how many
                languages are needed to add up to that percentage.

HELP
        exit 0 ;;
    *) : ;;
    esac
done

[ "$api" ] || {
    printf "No api url given\n"
    exit 1
}

shift $((OPTIND - 1))

IFS=,
case ",${valid_ranges[*]}," in
    *,"${range}",*) : ;;
    *) printf "Invalid range\n"; exit 1 ;;
esac
unset IFS

convertsecs() {
    ((h = ${1} / 3600))
    ((m = (${1} % 3600) / 60))
    ((s = ${1} % 60))
    printf "%02d:%02d:%02d\n" $h $m $s
}

milestones=(50)
if [ -n "$*" ]; then
    milestones=($(echo "$*" | tr '[:space:]' $'\n' | sort -n))
fi

raw=$(curl -s "$api"/api/compat/wakatime/v1/users/"${user:-euro}"/stats/"$range")

#day count doesn't include the current day, add one
day_count=$(($(echo "$raw" | jq .data.days_including_holidays) + 1))

list_slice="[0:]"
[ "$top" ] && list_slice="[0:$top]"
data="$(
    echo "$raw" |
    jq -r .data."$section""$list_slice"'.[]|"\(.name)\t\(.total_seconds)\t\(.percent)"'
)"

time_total=$((day_count * 86400))

total_secs_included=0

include_lang () {
    local lang="$1"
    [ "${exclude_langs[1]}" ] && {
        IFS=,
        case ",${exclude_langs[*]}," in
            *) unset IFS ;;&
            *,"${lang,,}",*) return 1 ;;
        esac
    }

    [ "${include_langs[1]}" ] && {
        IFS=,
        case ",${include_langs[*]}," in
            *) unset IFS ;;&
            *,"${lang,,}",*) : ;;
            *) return 1 ;;
        esac
    }

    return 0
}

while read -r lang secs pct; do
    include_lang "$lang" || continue

    total_secs_included=$((total_secs_included + secs))
done <<< "$data"

total_pct=0
total_secs=0
cur_milestone=0
lang_count=0

{
    while read -r lang secs pct; do
        include_lang "$lang" || continue

        [ "$use_real_total" = 0 ] && \
            pct=$(echo "print $secs / $total_secs_included * 100" | perl)

        total_pct=$(echo "print $total_pct + (${pct})" | perl)
        total_secs=$((total_secs + secs))

        lang_count=$((lang_count + 1))

        echo "$lang $(convertsecs "$secs") ($(printf '%.02f' "$pct"))"

        milestone_nr=${milestones[$cur_milestone]}
        while [ -n "$milestone_nr" ] && [ "$(bc <<<"${total_pct} > ${milestone_nr}")" = 1 ]; do
            printf "\x1b[1m%s%%-(%d) %s (%.2f%%)\x1b[0m\n" "$milestone_nr" "$lang_count" "$(convertsecs "$total_secs")" "${total_pct}"
            cur_milestone=$((cur_milestone + 1))
            milestone_nr=${milestones[$cur_milestone]}
        done
    done <<< "$data"

    printf -- "-------------\nTOTAL %s (%s%%)\n" "$(convertsecs "$total_secs")" "$(printf "%.02f" "$total_pct")"

    printf -- "--------------\nAVG %s time/day\n" "$(convertsecs "$(echo "printf '%.0f', $total_secs / $time_total * 86400" | perl)")"
} | column -t

